## Dynamic Programming Review

### Overlapping Subproblems

- Dynamic programming is an algorithmic paradigm the solves a problem by breaking it into subproblems and stores the results of subproblems to avoid recomputation
- Two core properties: overlapping subproblems and optimal substructure 
- Similar to divide and conquer (e.g. mergesort)
- Computed subproblems are stored in a table or structure to prevent recomputation
    - Not all kinds of problems lend themselves to this approach; e.g. a binary search traversal doesn't have this kind of problem, but a directed graph search would
    - Computer the fibonnaci sequence or testing whether or gathing prime numbers would also present a problem that has overlapping subproblems
- There are two ways to store subproblems: memoization and tabulation
    - A memoized program for a problem is similar to what we see in small recusive problem memoizations that reduce runtime
    - We initialize a lookup array and check it whenever we need a solution to a subproblem
    - With a tabulated problem, we build all the subproblems every time, first starting with our base case and then working our way to the final result

#### Fibonacci with Memoization
```javascript

const dynamicFibonacci = function(bound, seenNumbers = []) {
    if (n < 0 || typeof n !== 'number') {
        raise new Error("The fibonacci sequence is not valid for this input.")
    } else if (n < 2) {
        seenNumbers[n] = n;
    }

    if (!seenNumbers[n]) {
        seenNumbers[n] = dynamicFibonacci(n-1, seenNumbers) + dynamcFibonacci(n-2, seenNumbers);
    }
    return seenNumbers[n];
}

```

#### Fibonacci with Tabulation
```javascript

const dynamicFibonacci2 = function(
    bound, seenNumbers = [0, 1]
    ) {
    for (let i = 2; i < bound; i++) {
        seenNumbers[i] = seenNumbers[i-1] + seenNumbers[i-2];
    }
    return seenNumbers[-1];
}

```