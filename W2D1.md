## Topological Sort Video

- Given a directed, acyclic graph (DAG), sort all vertices from lower to higher order
- DFS wil help you with a topological sort
- Move through the vertices using DFS, then reverse, and you'll have the topological sort
- Great example: building a dependency graph
- Create a visited set and a sorted stack
- Visit children using DFS, putting them in the set
- If the children have no children / no more children, then put them in the stack 
- _Only_ possible for a directed, acyclic graph

```javascript
class Graph() {

    constructor() {
        this.numNodes = 0 //find a way to build this
    }

    topologicalSortHelper(vertex, visited, stack) {
        visited[vertex] = true;
        for (let i = 0; i < vertex.children, i++) {
            if (!visited[i]) {
                this.topologicalSortHelper(i, visited, stack);
            }
            stack.push(vertex);
        }
    }
    topologicalSort() {
        visited = {};
        stack = [];

        for (let j = 0; j < numNodes; j++) {
            //you would need an architecture that allows 
            //you to loop over the nodes like this
            if (!visited[j]) {
                this.topologicalSortHelper(j, visited, stack)
            }
        }
        //print stack in LIFO order to show ordered list
        for (k = 0; k < stack.length; k++) {
            console.log(stack[k]);
        }
    }

}
```

## Packets, Routers and Reliability

- Materials are not sent to you via direct, dedicated connections
- Information does not follow a fixed path when moving between two machines, especially when multiple packets are sent in the course of one conversation
- Packets in a message will be sent in various directions depending on the traffic that they encounter 
- The packets might not arrive in the sent order, but they need to be correctly reassembled 
- Packets contain information about where they're coming from, and where they're heading 
- Every router will keep track of multiple possible paths for delivering a packet 
- Often, the best route is not necessarily the more direct
- Multiple path options makes the internet fault-tolerant, delivery packets even when particular machines are down
- TCP (Transmission Control Protocol) is the guaranteed mail service of the Internet, ensuring that all needed packets have been received 
- Without a full receipt, TCP will not allow the assembly of packets / program to run 

## TCP / IP (Transmission Control Protocol / Internet Protocol) and related Techquickie Videos

- Online data needs to know where it's going 
- Layers of TCP: application layer (HTTP/SFTP), transport layer (TCP / UDP), internet layer (IP layer)
- Application layer and transport layer speak using ports on your computer 
- TCP distributes the sent information to another computer with the correct address and specified ordering 
- Internet layer sends TCP over to a specified IP address
- TCP / IP can deal with packets from all of you computer's applications so that your computer's programs doesn't need to design that itself 
- IP address will only get you as far as the modem that you have in your house
- Each device has a MAC address (media access control) will specify your adress, controlled by the final layer of TCP / IP
- ISPs use MAC address to control internet delivery to your specific devices in your home 
- IP dictates the way that headers are written to deliver packets, and also the path defined for moving the packet through space 
- IPv4 has only received minor changes from its original creation in the 1970s 
- IPv4 only allows for 4 billion unique addresses (we were reusing IP addresses for years)
- IPv6 allows trillions of trillions of unique addresses
 -IPv6 allows for auto-configuration for easier communication with other devices 

## Dijkstra's Algorithm

- Works on both directed and undirected graphs
- Basic pseudo code
    - Find the cheapest node
    - Update the costs of the immediate neighbors of this node
    - Repeat steps 1-2 until you've done this for every node
    - REturn the lowest cost to each node, and the optimal path to do so

### Pseudo code:
```javascript

const graph = {
    start: {A: 5, B: 2},
    A: {C: 4, D: 2},
    B: {A: 8, D: 7},
    C: {D: 6, finish: 3},
    finish: {}
};

const costs = {
    A: 5,
    B: 2,
    finish: null
}

const parents = {
    A: 'start'
    B: 'start'
    finish: null
}

const processed = ['start', 'A', 'B']

const lowestCostNode = (costs, processed) => {
    return Object.keys(costs).reduce((lowest, node) => {
        if (lowest = null || costs[node] < costs[lowest] {
            if (!processed.includes(node)) {
                lowest = node;
            }
        })
        return lowest;
    }, null)
};

const dijkstra = (graph) => {
    const costs = Object.assign({finish: null}, graph.start);
    const parents = {finish: null};

    for (let child in graph.start) {
        parents[child] = 'start';
    };
    const processed = [];

    let node = lowestCostNode(costs, processed);
    while (node) {
        let cost = costs[node];
        let children = graph[node];
        for (let n in children) {
            let newCost = cost + children[n];
            if (!costs[n]) {
                costs[n] = newCost;
                parents[n] = node;
            }
            if (costs[n] > newCost) {
                costs[n] = newCost;
                parents[n] = node;
            }
        }
        processed.push(node);
        node = lowestCostNode(costs, processed)
    }

    let optimalPath = ['finish'];
    let parents = parents.finish;

    while (parent) {
        optimalPath.push(parent);
        parent = parents[parent];

        optimalPath.reverse();

        const results = {
            distance: costs.finish,
            path: optimalPath
        }

        return results;
    }
}


```