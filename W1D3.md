## Trees, Heaps, Tries and Graphs (Cracking the Coding Interview)

- A tree is a data structure composed of nodes
- Each tree has a root node
- The root node has zero or more child nodes
- Each child node has zero or more child nodes, etc 
- A tree is typically an acyclic digraph, where children do not have a referene to the location of their parent 
- A binary tree is a tree i which each node has up to two children
- Binary trees are not the b-all end all of trees, but they are well known because of their quick lookup time (O logN), which make them useful for, e.g. an adjacency list used to search the edges in a graph 
- A binary search tree is one where the left children are strictly less than the right children throughout the graph, not just at a particular layer of the tree 
- When asked a tree, question, it is wise to enforce a strict understanding of which type of tree the interview wants to work with 
- Trees may be balanced, but not all trees are balanced 
- A balanced tree is one where the left/right distribution is rougly similar (it does not haves to be strictly even throughout the tree for the three to be balanced; cf. a dense vs sparse graph... it's a spectrum)
- A complete binary tree is a binary tree where all levels are filled except the lowermost leaf level
    - If the lowest level is filled, it must be filled left to right for the tree to be considered complete 
- A full binary tree is a tree where every node has either 0 or 2 children
- A perfect binary tree is one that is both full and complete (there won't be any left-only child nodes in the lowermost level)

### Tree Traversal Types: 

#### In-Order Traversal: Left, Parent, Right:

```javascript
const inOrderTraversal(node) {
    if (node !== null) {
        inOrderTraversal(node.left);
        visit(node);
        inOrderTraversal(node.right);
    }
}
```

### Pre-Order Traversal: Parent, Left, Right:

```javascript
const inOrderTraversal(node) {
    if (node !== null) {
        visit(node);
        inOrderTraversal(node.left);
        inOrderTraversal(node.right);
    }
}
```

### Post-Order Traversal: Left, Right, Parent:

```javascript
const inOrderTraversal(node) {
    if (node !== null) {
        visit(node);
        inOrderTraversal(node.right);
        inOrderTraversal(node.left);
    }
}
```

### Heaps 

- A min-heap is a complete binary tree where each node is smaller than its children
- The root is the minimum element in the tree 
- A max-heap is, of course, the opposite 
- There are two key operations in a heap: insert() and findMax(), findMin()
- To insert into a heap, we place the new elements at the leaf level and then bubble it up the tree by swapping it with its parents until we find its appropriate position (it is greater than its parent but smaller than both of its children)
- In a min/max heap, there is no inherit ordering between the left and right child nodes, except that they are always larger than their parent 

### Tries  (Prefix Trees)

- Tries are an n-ary where (n is number of letters in an alphabet) tree used to denote the construction of strings that represent real words
- Tries that terminate in a null node are a chain of letters that prefix and then ultimately form a complete word 
- Both a trie and a hash table would have a lookup time of O(len(word)) for a word, because even the hash table has to scan the entire word before looking it up

### Graphs

- A tree is an acyclic graph
- In general, a graph is a collection of nodes with edges (conections) between the nodes 
- Graphs can be directed (relationships are not necessarily mutual, e.g. a map of flights) or undirected (relationships are necessarily mutual, e.g. facebook friendships)
- If there is a path between all vertices in a graph, it's connected
- If there is a path from every vertex to every other vertex, we say that it's strongly connected
- The two common ways to search a graph and DFS and BFS 
    - Depth-first search starts at the root and explores every branch completely before moving on to the next branch (we consider the first sibling's children before considering its siblings)
    - Breadth-first search, typically invokes with a queue to hold the proper order of processing each nodes, explores all siblings of a given node before reviewing, in left-to-right order, their first generation of children (and then, left-to-right, that generation's children)
- Generally speaking, we prefer DFS when we want to search every node, but we prefer BFS when we think that our given target is somewhere near the root
- In-order, pre-order and post-order traversal are all forms of DFS
- BFS, unlike DFS, is not a recursive traversal 

```javascript 
    const breadthFirstTraversal(parent) {
        let queue = [];
        parent.marked = true
        queue.push(parent);

        while (queue.length) {
            let current = queue.unshift();
            current.children.forEach(child => {
                if (!child.marked) {
                    child.marked = true;
                    queue.push(child);
                }
            })
        }
    }
```
- Bidrectional search is used to find the shortest path between a source and a destination node
    - You basically run a BFS from each node; when they collide, you've found the path
    - In a traditional search, we would be looking at up to childrenPerNode^depth nodes, but with a bidirectional search, we are looking at up to childrenPerNode^depth/2, which is a huge improvement

## What happens when you visit Google?

- Part 1: Finding the IP address
    - Your browser checks its own cache for the DNS record of the site
    - Every site has its own DNS address; you can use this address to visit the site instead of its human-friendly name
    - If the browser can't find it, it checks the OS cahce
    - If the OS cache doesn't have it, the browser submits a request to the router's cache
    - If the router doesn't have it, it check with the ISP, moving through DNS servers until it locates the correct DNS record 
    - We cache data to reduce network loads for common addresses 
    - Servers that return IP addresses are called name servers 
    - With something that has a third-level domain, like maps.google.com, the DNS will first route to the name server for the main domain, google.com, and this server will route to the third-level name server that stores the correct IP address 
- Part 2: The TCP connection
    - The TCP/IP protocol is a three-way handshake
    - The client and server exchange SYN and ACK messages to establish a connection
    - The client sends a SYNchronize packet to the server asking if it will open a conection
    - The server, if it has open ports, will respond with an ACKnowlege message
    - The client will receive teh SYN/ACK packet and send back an ACKnowledgement that it has receive teh SYN/ACK
    - The connection is live 
- Part 3: The browser sends an HTTP request 
    - Browsers will start with a GET request for the page 
    - This request will also contain additional information such as a browser ID header (user-agent header), an acceptable response types header (accept header) and connection headers to keep the TCP connection alive 
    - E.G.
        - GET: web address
        - Accept: image/jpeg, application/xaml+xml
        - User-Agent: Mozilla/4.0
        - Accept-Encoding: gzip, deflate
        - Connection: Keep-Alive
        - Host: facebook.com
        - Cookie: cookieID#
-Part 4: The Web Server Responds
    - A web server at the IP address receives the request and passes it to a request handler (controller)
    - It assembles the response in a particular format, commonly JSON
    - E.G.
        - HTTP/1.1 200 OK
        - Cache-Control: private, no-store, no-cache
        - Expires: some date
        - P3P: privacy intentions
        - Pragma: no-cache
        - Content-Encoding: gzip
        - Content-Type: text/html, charset=utf-8
        - X-Cnection: close
        - Transfer-Encoding: chunked
        - Date: some date
-Part 5: The Browser displays the response
    - Typically, this is HTML or JSON delivered to client side HTML (e.g. in React)

## Geeks for Geeks: DFS for Graphs

- DFS for graphs is similar, except that we have to consider that graphs may be cyclic

```javascript

    const visitedTracker = {};
    const process = function(vertex) { 
        //do something to vertex
        } 
    const graphDFS = function(vertex, visitedTracker) {
        if (!visitedTracker[vertex]) {
            process(vertex);
            visitedTracker[vertex] = true;
            vertex.children.forEach(child =>
                graphDFS(child, visitedTracker)
            );
        };
    }
```

- OK, but what if the graph is disconnected? How do we process the orphaned nodes? 
    - We need a way to make sure that we iterate over all the nodes (more expensive, because it will basically force us to reexamine a few already visited nodes, confirm that we've visited them, and then move on)

## Geeks for Geeks: BFS for Graphs 

- Similar to trees, except that graphs may be cyclic
- Just like with DFS, we need a boolean visitedTracker object or array to determine whether or not we've already seen a child node

```javascript

    const visitedTracker = {};
    const process = function(vertex) { 
        //do something to vertex
        } 
    const graphBFS = function(startingVertex, visitedTracker) {
        const queue = [];
        queue.push(startingVertex)
        visitedTracker[startingVertex] = true;


        while (queue.length) {
            let currentVertex = queue.unshift();
            process(currentVertex);
            currentVertex.children.forEach(function(child) {
                if (!visitedTracker[child]) {
                    visitedTracker[child] = true;
                    queue.push(child);
                }
            }
                
        }
    }
```